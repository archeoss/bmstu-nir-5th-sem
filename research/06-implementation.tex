\chapter{Существующие решения}\label{ch:--}
\section{Обзор методов модификации ядра Linux}\label{sec:----linux}

%\subsection{Методы модификации ядра Linux}\label{subsec:---linux}
В настоящее время существует множество методов модификации ядра Linux.
Все они различаются по своим особенностям и применяемым технологиям.
В данном разделе рассмотрены наиболее популярные методы модификации ядра Linux.

\subsection{Методы модификации ядра Linux, основанные на перекомпиляции ядра}\label{subsec:---linux----}

На момент выпуска версии 1.0 ядра Linux существовал единственный метод модификации ядра Linux, основанный на перекомпиляции ядра.
В этом методе исходный код Linux изменяется под конкретные задачи и перекомпилируется с использованием специальных опций компилятора.
В результате получается модифицированное ядро Linux, которое можно использовать для запуска системы.
Однако, такой метод модификации ядра Linux имеет \textbf{ряд недостатков}:
\begin{enumerate}
    \item Необходимость перекомпиляции ядра Linux для каждого нового модуля. \vspace{5mm}\\
    Это означает, что при необходимости добавления нового модуля в систему необходимо будет перекомпилировать все ядро Linux.
    Таким образом, этот метод модификации ядра Linux не подходит для систем, в которых необходимо добавлять новые модули в систему динамически.

    \item Сложность добавления кода в ядро Linux. \vspace{5mm}\\
    Для добавления кода в ядро Linux необходимо уметь работать с языком и компилятором языка C, а также с инструментами конфигурации ядра Linux, знать интерфейс прикладного программирования ядра (API)\cite{API-linux}.
    Таким образом, данный метод модификации ядра Linux не подходит для людей, которые не имеют достаточной квалификации связанной с языком С или достаточных знаний связанных с Linux API\@.
    Иными словами данный подход требует крайне высокой квалификации и опыта программиста, что замедляет процесс разработки и внедрения новых модулей в систему.
    \vspace{5mm}\\
    \item Модифицированное ядро Linux не является частью исходного кода ядра Linux. \vspace{5mm}\\
    Поэтому, если в исходный код ядра Linux вносятся изменения, то исходный код модифицированного ядра Linux должен быть изменен вручную. (???)

    \item Если допустить ошибку при добавлении нового кода в ядро Linux, то есть шанс его повредить и сделать систему полностью нерабочей.
    При возникновении ошибки в ядре, то вся система также критично завершает работу.
\end{enumerate}

Однако у статического метода модификации ядра Linux есть и \textbf{преимущества}:

\begin{enumerate}
    \item Скорость работы системы.
    В статическом методе модификации ядра Linux не используется динамическая подгрузка модулей, поэтому модули ядра Linux загружаются в память только один раз, при запуске системы.
    Поэтому, в статическом методе модификации ядра Linux исключена возможность динамического добавления новых модулей в систему, что позволяет увеличить скорость работы системы.
    \item Отсутствие альтернативных методов модификации ядра Linux.
    Иногда необходимые дополнения не могут быть реализованы в виде модулей ядра Linux, поэтому в этом случае необходимо модифицировать исходный код ядра Linux.
    \item (???)
\end{enumerate}

\subsection{Методы модификации ядра Linux, основанные на встраивании модулей ядра}\label{subsec:---linux-----}

Второй метод модификации ядра Linux, основанный на встраивании модулей ядра, появился в 1995 году, когда в версию 1.2 была добавлена поддержка LKM - Loadable Kernel Module.
В этом методе ядро Linux не перекомпилируется.
Вместо этого используется специальный модуль ядра, который встраивается в ядро Linux.
В результате получается модифицированное ядро Linux, которое можно использовать для работы системы.

\includeimage
{lkm} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f}
{h}
{0.5\textwidth} % Ширина рисунка
{Взаимодействие ядра с загружаемыми модулями и пользовательскими приложениями.} % Подпись рисунка

В качестве примера можно привести модуль ядра, который предназначен для работы с сетевыми интерфейсами.
В этом модуле ядра реализованы функции, которые позволяют получить информацию о сетевых интерфейсах, а также управлять ими.
При этом, модуль ядра не содержит в себе никаких функций, которые не относятся к работе с сетевыми интерфейсами.
Таким образом, модуль ядра не засоряет ядро Linux ненужными функциями.
\vspace{5mm}\\
\textbf{Плюсы:}

\begin{enumerate}
    \item Модуль ядра может быть загружен в ядро Linux во время работы системы. \vspace{5mm}\\
    Таким образом, модуль ядра может быть загружен в ядро Linux во время работы системы.
    \item Модифицированное ядро Linux является частью исходного кода ядра Linux. \vspace{5mm}\\
    Поэтому, если в исходный код ядра Linux вносятся изменения, то исходный код модифицированного ядра Linux автоматически изменяется.
    \item Модуль ядра может сэкономить оперативную память,
    потому что появляется возможность загружать их только тогда, когда они действительно нужны, в то время как
    все части базового ядра все время остаются загруженными в реальном хранилище, а не только в виртуальном.
    \item Еще одним преимуществом LKM является то, что он помогают диагностировать системные проблемы. \vspace{5mm}\\
    Ошибка в драйвере устройства, связанном с ядром, может остановить загрузку системы, что может вызвать проблемы определить, какая часть базового ядра вызвала проблемы.
    Однако если тот же драйвер устройства является LKM, базовое ядро запускается и работает еще до загрузки драйвера устройства.
    Если система завершает работу после того, как базовое ядро запущено, то появляется возможность отследить проблему до вызывающего проблемы драйвера устройства и не загружать его до тех пока, проблема не будет решена.\\
\end{enumerate}
\textbf{Недостатки:}

\begin{enumerate}
    \item LKM может привести к проблемам с производительностью системы. \vspace{5mm}\\
    Поскольку LKM загружаются в ядро Linux во время работы системы, они могут увеличить время загрузки системы.
    \item В некоторых случаях LKM может привести к некоторым проблемам. \vspace{5mm}\\
    Например, LKM может привести к проблемам совместимости, если они не совместимы с базовым ядром.
    \item Еще одним из незначительных критических замечаний по поводу предпочтения модульного ядра статическому ядру является так называемый штраф за фрагментацию. \vspace{5mm}\\
    Базовое ядро всегда распаковывается в реальную непрерывную память своими программами установки;
    таким образом, базовый код ядра никогда не фрагментируется.
    Как только система находится в состоянии, в котором модули могут быть вставлены, например, после того, как были смонтированы файловые системы, содержащие модули, вполне вероятно,
    что любая новая вставка кода ядра приведет к фрагментации ядра, что приведет к незначительному снижению производительности, используя больше записей TLB,
    что приводит к большему количеству промахов TLB\@.
    \item Также как и при добавлении кода напрямую в ядро, если при работе модуля возникнет ошибка, то есть шанс, что система также экстренно завершит работу.
\end{enumerate}

\subsection{Kernel Live Patching}\label{subsec:kernel-live-patching}

Kernel Live Patching - это относительно новая функция ядра Linux, которая позволяет обновлять ядро Linux без перезагрузки системы.
Исправление ядра в реальном времени является важным компонентом стратегии управления серверами Linux и устранения уязвимостей.
\\
Что Live Patching делает, так это создают модуль ядра из исправленного кода, а затем с помощью инструмента ftrace (трассировка функции) перенаправляют от устаревшей функции к новой.
\includeimage
{Livepatch} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f}
{h}
{0.75\textwidth} % Ширина рисунка
{Концепт Live Patching} % Подпись рисунка

\textbf{Преимущества:}

\begin{enumerate}
    \item Позволяет обновлять ядро Linux без перезагрузки системы.
    \item Обновление системы требует времени и высокого уровня навыков системного администрирования.
    Live Patching избавляет персонал от рутинной работы по рутинному обслуживанию многочисленных серверов.
    \item Обновления проходят достаточно быстро, что позволяет оперативное разворачивание новых функций.
\end{enumerate}

\textbf{Недостатки:}

\begin{enumerate}
    \item Внесение исправлений в ядро по-прежнему довольно сложно — исправления должны быть написаны экспертами для каждой системы,
    и они зарезервированы только для важных исправлений безопасности.
    Даже в этом случае не гарантируется, что система не выйдет из строя.
    \item Live Patching может применяться только к небольшим и конкретным частям кода ядра и не может использоваться для каких-либо серьезных обновлений,
    которые затрагивают несколько компонентов или изменяют структуры данных.
    \vspace{0.5cm}
    Изменения в структурах данных усложняют ситуацию, поскольку данные должны оставаться на месте и не могут быть расширены или переинтерпретированы.
    Хотя существуют методы, которые позволяют косвенно изменять структуры данных, некоторые изменения нельзя преобразовать в подобного рода исправления.
    В этой ситуации перезагрузка системы — единственный способ применить все изменения.
    \item Не все ядра поддерживают Live Patching.
    В различных ядрах используются разные методы управления процессом исправления и создания исправлений,
    а некоторые из них разработаны исключительно под определенные семейства Linux.\cite{infosec}
\end{enumerate}

\subsection{eBPF}\label{subsec:ebpf}

eBPF (extended Berkeley Packet Filter) - это новая технология, которая позволяет встраивать программы в ядро Linux, не изменяя его исходный код.
В своей основе eBPF использует привилегированную способность ядра видеть и контролировать все ресурсы системы.
С помощью eBPF есть возможность запускать изолированные программы в привилегированном контексте, таком как ядро операционной системы.
\includeimage
{eBPF_work} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f}
{h}
{0.75\textwidth} % Ширина рисунка
{Алгоритм eBPF} % Подпись рисунка
\vspace{5mm}\\

\textbf{Преимущества:}

\begin{enumerate}
    \item eBPF позволяет встраивать программы в ядро Linux, не изменяя его исходный код.
    \item Поскольку программа eBPF не изменяет код ядра, появляется возможность сохранить правила управления доступом для изменений на уровне кода.
    Кроме того, программы написанные с помощью eBPF имеют этап проверки, который предотвращает чрезмерное использование ресурсов.
    \item eBPF может перенести обработку пакетов из пространства ядра в пространство пользователя. \vspace{5mm}\\
    Иными словами eBPF является JIT-компилятором.
    После компиляции байт-кода вызывается eBPF, а не новая интерпретация байт-кода для каждого метода.\\
\end{enumerate}

\textbf{Недостатки:}

\begin{enumerate}
    \item Главный минус eBPF заключается в том, что количество программ в песочнице ограничено. \vspace{5mm}\\
    eBPF обеспечивает повышенную безопасность, ограничивая доступ программ к ресурсам.
    Однако из-за такого ограничения, к каким частям ОС программа может получить доступ, функциональность данного метода также ограничена.
    \item В случае если необходимо внести изменения в ядро, то eBPF просто не обладает данной возможностью.
    \item Поскольку eBPF выполняет программы в привилегированном контексте, то это может привести к утечке конфиденциальной информации.
\end{enumerate}

В конце данного раздела стоит сделать оговорку касательно eBPF\@.
\vspace{5mm}\\
В реальности eBPF \textbf{не существует}, или если быть точнее, не является полноценным инструментом модификации ядра де-факто.
\vspace{5mm}\\
eBPF — это всего лишь набор инструкций, для которых ядро Linux предоставляет виртуальную машину, верификатор и некоторые вспомогательные функции.
Программы запускаются внутри этого контекста выполнения и вызывают вспомогательные функции для расширения возможностей виртуальной машины.
Во время выполнения программы eBPF на самом деле вызываются kprobe, или uprobe, или классификатор eXpress Data Path (XDP),
или один из многих других типов программ пространства ядра, которые были выгружены в подсистему eBPF\@.
\\
Таким образом, eBPF-программы — это не полноценные модификации ядра Linux, а лишь наборы инструкций, которые позволяют расширить возможности уже существующего ядра\@.
Но не смотря на это, по формальным признакам, eBPF подходит под все критерии, которые были описаны в начале данной работы,
являясь при этом крайне мощным инструментом при написании определенного типа программ, что и послужило причиной для его включения в данную работу.
\section{Критерии сравнения методов модификации ядра}\label{sec:----}
В данном разделе будут описаны критерии, которые будут использоваться для сравнения методов модификации ядра.

\begin{table}[H]
\begin{center}
    \begin{threeparttable}
      \captionsetup{justification=raggedright,singlelinecheck=off}
      \caption{\label{tab:criteria}Критерии сравнения методов модификации ядра}
        \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Критерий} & \textbf{Описание} \\ \hline
        \textbf{Производительность} & Производительность программ. \\ \hline
        \textbf{Безопасность} & Наличие гарантии, что внесенный код не вызовет остановку системы. \\ \hline
        \textbf{Скорость разработки} & Скорость разработки модификации. \\ \hline
        \textbf{Скорость загрузки} & Скорость загрузки модификаций при запуске системы. \\ \hline
        \textbf{Гибкость} & Возможность метода подстроиться под любые поставленные бизнес-задачи. \\ \hline
        \textbf{Простота отладки} & Является ли написанные модификации простыми в отладке. \\ \hline
        %\textbf{Кроссплатформенность} & Возможность использования модификаций на разных архитектурах. \\ \hline
        \textbf{Поддержка} & Поддержка метода разработчиками ядра при его написании. \\ \hline
        \textbf{Простота развёртывания} & Насколько сложно развёртывать модификации на большом количестве машин. \\ \hline
        \end{tabular}
    \end{threeparttable}
\end{center}
\end{table}
\newpage
\section{Сравнение методов модификации ядра}\label{sec:---}
\textbf{TODO: добавить комментарии к сравнению}
% cmark and xmark defined in research.tex

\begin{table}[H]
\begin{center}
    \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{\label{tab:comparison} Сравнение методов модификации ядра}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            \textbf{Критерий} & \textbf{Рекомпиляция} & \textbf{LKM} & \textbf{Live Patching} & \textbf{eBPF} \\ \hline
            \textbf{Производительность} & \cmark & \cmark & \cmark & \cmark \\ \hline
            \textbf{Безопасность} & \xmark & \xmark & \xmark & \cmark \\ \hline
            \textbf{Скорость разработки} & \xmark & \cmark & \xmark & \cmark \\ \hline
            \textbf{Скорость загрузки} & \cmark & \cmark & \cmark & \cmark \\ \hline
            \textbf{Гибкость} & \cmark & \cmark & \xmark & \xmark \\ \hline
            \textbf{Простота отладки} & \xmark & \cmark/\xmark\footnotemark{} & \xmark & \cmark \\ \hline
%            \textbf{Кроссплатформенность} & \cmark & \cmark/\xmark & \cmark & \cmark \\ \hline
            \textbf{Поддержка} & \cmark & \cmark & \cmark & \xmark \\ \hline
            \textbf{Простота развёртывания} & \xmark & \cmark & \cmark & \cmark \\ \hline
        \end{tabular}
    \end{threeparttable}
\end{center}
\end{table}

\footnotetext{Несмотря на то, что в данном методе отладка происходит гораздо легче, чем при встраивании кода в само ядро, как при рекомпиляции или Live Patching'е, отладка модулей всё равно может вызвать ряд проблем.}
